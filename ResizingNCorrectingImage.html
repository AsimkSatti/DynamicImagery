<!DOCTYPE html>
<html lang="en">

<head>
    <title>Pixel to Point</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style type="text/css">
    #SourceImage {
        display: none;
    }

    #myCanvas {
        display: none;
    }

    * {
        margin: 0;
        padding: 0;
    }
    </style>
</head>

<body>
    <img id="SourceImage" src="Toonme.png">
    <canvas id="myCanvas" width=1625 height=1875 style="position:fixed;"></canvas>
</body> 
<script type="module">
    var data;
        var offset=1;
        import * as THREE from '/three.js-master/build/three.module.js';
                

  
       function imageGenerator(){

       var image = document.getElementById("SourceImage");
        var canvas = document.getElementById('myCanvas');
        var context = canvas.getContext('2d');
 
        var x = 0;
        var y = 0;
        canvas.width = image.width;
        canvas.height = image.height;



        canvas.addEventListener(
      'webglcontextlost', handleContextLost, false);

        context.drawImage(image, x, y);

        var imageData = context.getImageData(x, y, image.width, image.height);
        data = imageData.data;



        var counter=0
 
 
 
        

        // overwrite original image
        context.putImageData(imageData, x, y);
     
     }
      

     function handleContextLost(event) {
   event.preventDefault();
   cancelRequestAnimationFrame(requestId);
}

    var Cloud = [];
 
         var geometry = new THREE.BufferGeometry();

    var scene, camera, renderer;

    // I guess we need this stuff too
    var container, HEIGHT,
        WIDTH, fieldOfView, aspectRatio,
        nearPlane, farPlane, stats,
        geometry, particleCount,
        i, j, h, color, size,
        materials = [],
        mouseX = 0,
        mouseY = 0,
        windowHalfX, windowHalfY, cameraZ,
        fogHex, fogDensity, parameters = {},
        parameterCount, particles,partlce;


         var colors = [];
        var color = new THREE.Color();
        var points;
        var count=0;
        var rotations=[];
        var didRenderImage=false;
        var timesEntered=0;


    init();
    animate();

 

    function init() {

        HEIGHT = window.innerHeight;
        WIDTH = window.innerWidth;
        windowHalfX = WIDTH / 2;
        windowHalfY = HEIGHT / 2;

        fieldOfView = 75;
        aspectRatio = WIDTH / HEIGHT;
        nearPlane = 1;
        farPlane = 6000;


        /*  fieldOfView — Camera frustum vertical field of view.
    aspectRatio — Camera frustum aspect ratio.
    nearPlane — Camera frustum near plane.
    farPlane — Camera frustum far plane.

    - https://threejs.org/docs/#Reference/Cameras/PerspectiveCamera

    In geometry, a frustum (plural: frusta or frustums)
    is the portion of a solid (normally a cone or pyramid)
    that lies between two parallel planes cutting it. - wikipedia.      */

        cameraZ = 2750;//farPlane / 3; /*  So, 1000? Yes! move on! */
        fogHex = 0xffffff; /* As black as your heart.   */
        fogDensity = 0.0001; /* So not terribly dense?  */

        camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
        camera.position.z = cameraZ;


        scene = new THREE.Scene();
        // scene.background = new THREE.Color(0xffffff);
        // scene.fog = new THREE.FogExp2(fogHex, fogDensity);

        container = document.createElement('div');
        document.body.appendChild(container);
        document.body.style.margin = 0;
        document.body.style.overflow = 'hidden';

 

         var positions = [];
                 
        particleCount = 4025;  //the height required pick how much you want
 

        for (i = 0; i < particleCount; i+=2) {
                        //J is the width *2 as taken 2 steps
             for(j =0; j<3250; j+=2){


                // X is the height and Y is the width
                var x = Math.random()*0+ i-2000;
                var y =Math.random()*0+ j-1500;
                var z =Math.random()*2000;
                // var z=0;



                 positions.push(x,y,z);
                 color.setRGB( 1,0,0);
                 colors.push( color.r, color.g, color.b );



                // geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

                  };

        }

            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
           geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
            geometry.setAttribute( 'rotation', new THREE.Float32BufferAttribute( rotations, 3 ) );

          
            var material = new THREE.PointsMaterial( { size: 15, vertexColors: true } );
            points = new THREE.Points( geometry, material );

            scene.add( points );
            points.rotation.z=300;



       var light = new THREE.DirectionalLight( 0xffffff, 1 );
            scene.add(  light )
        light.target = points;
        

 

        renderer = new THREE.WebGLRenderer();  
        renderer.setPixelRatio(window.devicePixelRatio); 
        renderer.setSize(WIDTH, HEIGHT); 

        container.appendChild(renderer.domElement); 
 

        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener('mousemove', onDocumentMouseMove, false);
        document.addEventListener('touchstart', onDocumentTouchStart, false);
        document.addEventListener('touchmove', onDocumentTouchMove, false);

    }

    function animate() {
        requestAnimationFrame(animate);
        render();
        // stats.update();
    }

    function imageCasting(){



        for (var i = 0; i < 10000000; i+=3) {
            // BGR :: RGB
            colors[i+count]=(data[i+count +offset]/255);
            // colors[i+1+count]=(0;
            colors[i+1+count]=(data[i+1+count +offset]/255);
            colors[i+2+count]=(data[i+2+count +offset]/255);
 
            offset+=1;
   
         } 

          geometry.setAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );
   
         offset=0;

    }


    function update(){
    var time = Date.now() * 0.00005;
    var pixAtATime=100;

    if(data &&timesEntered<4){
        imageCasting();
        timesEntered+=1;
    }

        // camera.position.x += (mouseX - camera.position.x) * 0.05;
        camera.position.x += 1.5*(mouseX - camera.position.x) * 0.05;

        camera.position.y += 1.5*(-mouseY - camera.position.y) * 0.05;
        // particles.position.z-=(mouseX - camera.position.x) * 0.05;

        camera.lookAt(scene.position);
        scene.children[1].position.z-=(mouseX - camera.position.x) * 0.05;
 
        for (i = 0; i < scene.children.length; i++) {
             scene.children[i].scale.z+=((Math.sin(time)));


 
            var object = scene.children[i];

       
        }

 

    }

    function render() {
        update();
        renderer.render(scene, camera);
    }

    function onDocumentMouseMove(e) {
        mouseX = e.clientX - windowHalfX;
        mouseY = e.clientY - windowHalfY;
    }

    /*  Mobile users?  I got your back homey    */

    function onDocumentTouchStart(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onDocumentTouchMove(e) {

        if (e.touches.length === 1) {

            e.preventDefault();
            mouseX = e.touches[0].pageX - windowHalfX;
            mouseY = e.touches[0].pageY - windowHalfY;
        }
    }

    function onWindowResize() {

        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }


window.addEventListener('load', imageGenerator);

        </script>

</html>